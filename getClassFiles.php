#!/usr/bin/php
<?php

set_error_handler( function ($errno, $errstr, $errfile, $errline) {
	throw new ErrorException($errstr, $errno, 0, $errfile, $errline);
} );

//	Use this for uncaught exceptions so we can see all the useful details.
set_exception_handler( function (\Exception $e) {
	while ( ob_get_level() ) {
		ob_end_flush();
	}

	fwrite(STDERR, PHP_EOL . $e . PHP_EOL);
	exit($e->getCode());
} );


////////////////////////////////////////////////////////////////////////////////
if( count($argv) === 1 ) {
	fwrite(STDERR, 'Type the command plus one or more paths to check.' . PHP_EOL);
	fwrite(STDERR, $argv[0] . ' <path>[ <path>[ ...]]' . PHP_EOL);
	exit(1);
}

//	Drop application name.
array_shift($argv);


if ( !defined('T_TRAIT') ) {
	define('T_TRAIT', -1);
}

$class2File = [];

foreach ( $argv as $path ) {
	$realPath = realpath($path);
	if ( !is_dir($realPath) ) {
		fwrite(STDERR, 'The path "' . $path . '" does not exist.' . PHP_EOL);
		continue;
	}

	fwrite(STDOUT, 'Loading from "' . $path . '".' . PHP_EOL);

	$iter = new RecursiveIteratorIterator(
		new RecursiveDirectoryIterator($realPath, RecursiveDirectoryIterator::SKIP_DOTS)
	);

	foreach ($iter as $f) {
		if ( strcasecmp(pathinfo($f, PATHINFO_EXTENSION), 'php') !== 0 ) {
			continue;
		}

		$tokens = token_get_all( file_get_contents($f) );

		//	Reset namespace for each file.
		$namespace = '';
		$count = count($tokens);
		for ($i = 0; $i < $count; ++$i) {
			if (!is_array($tokens[$i])) {
				continue;
			}

			switch ($tokens[$i][0]) {
				case T_NAMESPACE:
				while ( $tokens[$i][0]!==T_STRING && $tokens[$i][0]!==T_NS_SEPARATOR ) {
					++$i;	//	skip next token («whitespace», «comment», «;»)
				}

				for (; $i < $count && ($tokens[$i][0]===T_STRING||$tokens[$i][0]===T_NS_SEPARATOR); ++$i) {
					$namespace .= $tokens[$i][1];
				}

				$namespace .= '\\';
				break;

				case T_TRAIT:
				case T_CLASS:
				// ignore T_CLASS after T_DOUBLE_COLON to allow PHP >=5.5 FQCN scalar resolution
				if ($i > 0 && is_array($tokens[$i-1]) && $tokens[$i-1][0] === T_DOUBLE_COLON) {
					break;
				}
				case T_INTERFACE:
				// Abstract class, class, interface or trait found
				for ($i++; $i < $count; $i++) {
					//	get only the next string
					if (T_STRING === $tokens[$i][0]) {
						$class2File[ $namespace . $tokens[$i][1] ] = $f->__toString();
						break;
					}
				}
				break;

				default:
				break;
			}
		}
	}
}

ksort($class2File, SORT_STRING);

// var_export($class2File);

//	Write output to a C++ text file.
$fp = fopen('AutoloadValues.cp', 'w');

fwrite($fp, '
//	This file was generated by getClassFiles.php.

#include "AutoloadValues.h"

const std::unordered_map<std::string, const char *, Hash> AutoloadValues::_val = {
');

foreach ( $class2File as $c=>$p ) {
	fwrite( $fp, sprintf("\t{\"%s\", \"%s\"},\n", addslashes($c), $p) );
}

//	remove last comma
fseek($fp, -2, SEEK_END);

fwrite($fp, "\n};\n");
fclose($fp);

// fwrite(STDOUT, PHP_EOL);
